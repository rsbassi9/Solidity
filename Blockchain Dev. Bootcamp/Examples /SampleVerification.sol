//SPDX-License-Identifier: MIT

pragma solidity ^0.8.16;

contract MyContract {
    mapping(address => uint) public balance;

    constructor() {
        balance[msg.sender] = 100;
    } 

    function transfer(address to, uint amount) public {
        balance[msg.sender] -= amount;
        balance[to] += amount;
    }

    function someCrypticFunctionName(address _addr) public view returns(uint) {
        return balance[_addr];
    }
}

/*
NOTES:

Why Verify Smart ContractsÂ¶
First and foremost, in an open society that fosters transparency, it is considered good practice to open source the source code. Your bytecode is there anyways. But having the source code there is an additional step towards transparency.

In a world where smart contracts can handle multiple millions of dollars, its hard to justify for the wider public to interact with smart contracts if they can't be verified.

Verifying smart contracts also lets other easier interact with them, as you'll see in a second.

How to Verify A Smart Contract manually on Etherscan:
1. Run the smart contract using metamask
2. Sign in to Etherscan (Create an account if necessary)
3. Click "View on Etherscan" to open the transaction on Etherscan in Remix 
4. Etherscan: Click on the new Contract (the address) to open the contract
5. Then click on the Contract - you see its just bytecode there. Etherscan can't guess your interface, your function names, nothing.
    **sometimes Etherscan infers a function name. That is, for interfaces from known contracts, like the ERC20 contract. If you interact with this smart contract and use the transfer function, Etherscan would probably show you correctly that the function "transfer" was used. But if you use the function someCrypticFunctionName it would just show you the 4 byte hashed function signature.
6. Click "Verify and Publish"
7. There are two things to select: The compiler (Solidity single-file, version you are using ) and the license (MIT in this case).
8. Click continue, then paste the source code from remix into etherscan.
9. Sometimes you need to specify the compiler optimizations. To check if you had any, head back to Remix, and click "Advanced Configurations" in the compiler plugin. If the "enable optimization" box is checked, then set the same optimization in etherscan as well.
10. It should say something like "Successfully generated ByteCode and ABI for Contract Address "
11. Click on your contract address to get back
12. Click "Contract" - which now has a little check next to it
13. Click "Read Contract"
14. Let's interact with our smart contract. Click "Write"
15. Click "Connect to Web3"
16. Confirm the dialog box
17. Select "MetaMask" from the options & select account
18. Click "1. transfer" and copy the second account address form Metamask
19. Click "amount (uint256)" -> write -> confirm
20. Click "Read Contract"
21. Now lets read out the balance. Click "1. balance" and paste in the same account that we used for transferring the funds to
22. And simple click "Query" to show you the balance of account 1

 */